{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\n\nfunction _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nconst mm = require(\"micromatch\");\n\nconst HarmonyExportImportedSpecifierDependency = require(\"../dependencies/HarmonyExportImportedSpecifierDependency\");\n\nconst HarmonyImportSideEffectDependency = require(\"../dependencies/HarmonyImportSideEffectDependency\");\n\nconst HarmonyImportSpecifierDependency = require(\"../dependencies/HarmonyImportSpecifierDependency\");\n/** @typedef {import(\"../Module\")} Module */\n\n/** @typedef {import(\"../Dependency\")} Dependency */\n\n/**\n * @typedef {Object} ExportInModule\n * @property {Module} module the module\n * @property {string} exportName the name of the export\n * @property {boolean} checked if the export is conditional\n */\n\n/**\n * @typedef {Object} ReexportInfo\n * @property {Map<string, ExportInModule[]>} static\n * @property {Map<Module, Set<string>>} dynamic\n */\n\n/**\n * @param {ReexportInfo} info info object\n * @param {string} exportName name of export\n * @returns {ExportInModule | undefined} static export\n */\n\n\nconst getMappingFromInfo = (info, exportName) => {\n  const staticMappings = info.static.get(exportName);\n\n  if (staticMappings !== undefined) {\n    if (staticMappings.length === 1) return staticMappings[0];\n    return undefined;\n  }\n\n  const dynamicMappings = Array.from(info.dynamic).filter(_ref => {\n    let _ref2 = _slicedToArray(_ref, 2),\n        _ = _ref2[0],\n        ignored = _ref2[1];\n\n    return !ignored.has(exportName);\n  });\n\n  if (dynamicMappings.length === 1) {\n    return {\n      module: dynamicMappings[0][0],\n      exportName,\n      checked: true\n    };\n  }\n\n  return undefined;\n};\n/**\n * @param {ReexportInfo} info info object\n * @param {string} exportName name of export of source module\n * @param {Module} module the target module\n * @param {string} innerExportName name of export of target module\n * @param {boolean} checked true, if existence of target module is checked\n */\n\n\nconst addStaticReexport = (info, exportName, module, innerExportName, checked) => {\n  let mappings = info.static.get(exportName);\n\n  if (mappings !== undefined) {\n    for (const mapping of mappings) {\n      if (mapping.module === module && mapping.exportName === innerExportName) {\n        mapping.checked = mapping.checked && checked;\n        return;\n      }\n    }\n  } else {\n    mappings = [];\n    info.static.set(exportName, mappings);\n  }\n\n  mappings.push({\n    module,\n    exportName: innerExportName,\n    checked\n  });\n};\n/**\n * @param {ReexportInfo} info info object\n * @param {Module} module the reexport module\n * @param {Set<string>} ignored ignore list\n * @returns {void}\n */\n\n\nconst addDynamicReexport = (info, module, ignored) => {\n  const existingList = info.dynamic.get(module);\n\n  if (existingList !== undefined) {\n    for (const key of existingList) {\n      if (!ignored.has(key)) existingList.delete(key);\n    }\n  } else {\n    info.dynamic.set(module, new Set(ignored));\n  }\n};\n\nclass SideEffectsFlagPlugin {\n  apply(compiler) {\n    compiler.hooks.normalModuleFactory.tap(\"SideEffectsFlagPlugin\", nmf => {\n      nmf.hooks.module.tap(\"SideEffectsFlagPlugin\", (module, data) => {\n        const resolveData = data.resourceResolveData;\n\n        if (resolveData && resolveData.descriptionFileData && resolveData.relativePath) {\n          const sideEffects = resolveData.descriptionFileData.sideEffects;\n          const hasSideEffects = SideEffectsFlagPlugin.moduleHasSideEffects(resolveData.relativePath, sideEffects);\n\n          if (!hasSideEffects) {\n            module.factoryMeta.sideEffectFree = true;\n          }\n        }\n\n        return module;\n      });\n      nmf.hooks.module.tap(\"SideEffectsFlagPlugin\", (module, data) => {\n        if (data.settings.sideEffects === false) {\n          module.factoryMeta.sideEffectFree = true;\n        } else if (data.settings.sideEffects === true) {\n          module.factoryMeta.sideEffectFree = false;\n        }\n      });\n    });\n    compiler.hooks.compilation.tap(\"SideEffectsFlagPlugin\", compilation => {\n      compilation.hooks.optimizeDependencies.tap(\"SideEffectsFlagPlugin\", modules => {\n        /** @type {Map<Module, ReexportInfo>} */\n        const reexportMaps = new Map(); // Capture reexports of sideEffectFree modules\n\n        for (const module of modules) {\n          /** @type {Dependency[]} */\n          const removeDependencies = [];\n\n          for (const dep of module.dependencies) {\n            if (dep instanceof HarmonyImportSideEffectDependency) {\n              if (dep.module && dep.module.factoryMeta.sideEffectFree) {\n                removeDependencies.push(dep);\n              }\n            } else if (dep instanceof HarmonyExportImportedSpecifierDependency) {\n              if (module.factoryMeta.sideEffectFree) {\n                const mode = dep.getMode(true);\n\n                if (mode.type === \"safe-reexport\" || mode.type === \"checked-reexport\" || mode.type === \"dynamic-reexport\" || mode.type === \"reexport-non-harmony-default\" || mode.type === \"reexport-non-harmony-default-strict\" || mode.type === \"reexport-named-default\") {\n                  let info = reexportMaps.get(module);\n\n                  if (!info) {\n                    reexportMaps.set(module, info = {\n                      static: new Map(),\n                      dynamic: new Map()\n                    });\n                  }\n\n                  const targetModule = dep._module;\n\n                  switch (mode.type) {\n                    case \"safe-reexport\":\n                      for (const _ref3 of mode.map) {\n                        var _ref4 = _slicedToArray(_ref3, 2);\n\n                        const key = _ref4[0];\n                        const id = _ref4[1];\n\n                        if (id) {\n                          addStaticReexport(info, key, targetModule, id, false);\n                        }\n                      }\n\n                      break;\n\n                    case \"checked-reexport\":\n                      for (const _ref5 of mode.map) {\n                        var _ref6 = _slicedToArray(_ref5, 2);\n\n                        const key = _ref6[0];\n                        const id = _ref6[1];\n\n                        if (id) {\n                          addStaticReexport(info, key, targetModule, id, true);\n                        }\n                      }\n\n                      break;\n\n                    case \"dynamic-reexport\":\n                      addDynamicReexport(info, targetModule, mode.ignored);\n                      break;\n\n                    case \"reexport-non-harmony-default\":\n                    case \"reexport-non-harmony-default-strict\":\n                    case \"reexport-named-default\":\n                      addStaticReexport(info, mode.name, targetModule, \"default\", false);\n                      break;\n                  }\n                }\n              }\n            }\n          }\n        } // Flatten reexports\n\n\n        for (const info of reexportMaps.values()) {\n          const dynamicReexports = info.dynamic;\n          info.dynamic = new Map();\n\n          for (const reexport of dynamicReexports) {\n            let _reexport = _slicedToArray(reexport, 2),\n                targetModule = _reexport[0],\n                ignored = _reexport[1];\n\n            for (;;) {\n              const innerInfo = reexportMaps.get(targetModule);\n              if (!innerInfo) break;\n\n              for (const _ref7 of innerInfo.static) {\n                var _ref8 = _slicedToArray(_ref7, 2);\n\n                const key = _ref8[0];\n                const reexports = _ref8[1];\n                if (ignored.has(key)) continue;\n\n                for (const _ref9 of reexports) {\n                  const module = _ref9.module;\n                  const exportName = _ref9.exportName;\n                  const checked = _ref9.checked;\n                  addStaticReexport(info, key, module, exportName, checked);\n                }\n              } // Follow dynamic reexport if there is only one\n\n\n              if (innerInfo.dynamic.size !== 1) {\n                // When there are more then one, we don't know which one\n                break;\n              }\n\n              ignored = new Set(ignored);\n\n              for (const _ref10 of innerInfo.dynamic) {\n                var _ref11 = _slicedToArray(_ref10, 2);\n\n                const innerModule = _ref11[0];\n                const innerIgnored = _ref11[1];\n\n                for (const key of innerIgnored) {\n                  if (ignored.has(key)) continue; // This reexports ends here\n\n                  addStaticReexport(info, key, targetModule, key, true);\n                  ignored.add(key);\n                }\n\n                targetModule = innerModule;\n              }\n            } // Update reexport as all other cases has been handled\n\n\n            addDynamicReexport(info, targetModule, ignored);\n          }\n        }\n\n        for (const info of reexportMaps.values()) {\n          const staticReexports = info.static;\n          info.static = new Map();\n\n          for (const _ref12 of staticReexports) {\n            var _ref13 = _slicedToArray(_ref12, 2);\n\n            const key = _ref13[0];\n            const reexports = _ref13[1];\n\n            for (let mapping of reexports) {\n              for (;;) {\n                const innerInfo = reexportMaps.get(mapping.module);\n                if (!innerInfo) break;\n                const newMapping = getMappingFromInfo(innerInfo, mapping.exportName);\n                if (!newMapping) break;\n                mapping = newMapping;\n              }\n\n              addStaticReexport(info, key, mapping.module, mapping.exportName, mapping.checked);\n            }\n          }\n        } // Update imports along the reexports from sideEffectFree modules\n\n\n        for (const pair of reexportMaps) {\n          const module = pair[0];\n          const info = pair[1];\n          let newReasons = undefined;\n\n          for (let i = 0; i < module.reasons.length; i++) {\n            const reason = module.reasons[i];\n            const dep = reason.dependency;\n\n            if ((dep instanceof HarmonyExportImportedSpecifierDependency || dep instanceof HarmonyImportSpecifierDependency && !dep.namespaceObjectAsContext) && dep._id) {\n              const mapping = getMappingFromInfo(info, dep._id);\n\n              if (mapping) {\n                dep.redirectedModule = mapping.module;\n                dep.redirectedId = mapping.exportName;\n                mapping.module.addReason(reason.module, dep, reason.explanation ? reason.explanation + \" (skipped side-effect-free modules)\" : \"(skipped side-effect-free modules)\"); // removing the currect reason, by not adding it to the newReasons array\n                // lazily create the newReasons array\n\n                if (newReasons === undefined) {\n                  newReasons = i === 0 ? [] : module.reasons.slice(0, i);\n                }\n\n                continue;\n              }\n            }\n\n            if (newReasons !== undefined) newReasons.push(reason);\n          }\n\n          if (newReasons !== undefined) {\n            module.reasons = newReasons;\n          }\n        }\n      });\n    });\n  }\n\n  static moduleHasSideEffects(moduleName, flagValue) {\n    switch (typeof flagValue) {\n      case \"undefined\":\n        return true;\n\n      case \"boolean\":\n        return flagValue;\n\n      case \"string\":\n        if (process.platform === \"win32\") {\n          flagValue = flagValue.replace(/\\\\/g, \"/\");\n        }\n\n        return mm.isMatch(moduleName, flagValue, {\n          matchBase: true\n        });\n\n      case \"object\":\n        return flagValue.some(glob => SideEffectsFlagPlugin.moduleHasSideEffects(moduleName, glob));\n    }\n  }\n\n}\n\nmodule.exports = SideEffectsFlagPlugin;","map":null,"metadata":{},"sourceType":"module"}