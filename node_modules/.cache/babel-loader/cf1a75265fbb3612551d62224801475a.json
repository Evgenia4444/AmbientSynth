{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\n\nfunction _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nconst Generator = require(\"../Generator\");\n\nconst Template = require(\"../Template\");\n\nconst _require = require(\"webpack-sources\"),\n      RawSource = _require.RawSource;\n\nconst WebAssemblyImportDependency = require(\"../dependencies/WebAssemblyImportDependency\");\n\nconst WebAssemblyExportImportedDependency = require(\"../dependencies/WebAssemblyExportImportedDependency\");\n/** @typedef {import(\"../NormalModule\")} NormalModule */\n\n/** @typedef {import(\"../RuntimeTemplate\")} RuntimeTemplate */\n\n/** @typedef {import(\"webpack-sources\").Source} Source */\n\n/** @typedef {import(\"../Dependency\").DependencyTemplate} DependencyTemplate */\n\n\nclass WebAssemblyJavascriptGenerator extends Generator {\n  /**\n   * @param {NormalModule} module module for which the code should be generated\n   * @param {Map<Function, DependencyTemplate>} dependencyTemplates mapping from dependencies to templates\n   * @param {RuntimeTemplate} runtimeTemplate the runtime template\n   * @param {string} type which kind of code should be generated\n   * @returns {Source} generated code\n   */\n  generate(module, dependencyTemplates, runtimeTemplate, type) {\n    const initIdentifer = Array.isArray(module.usedExports) ? Template.numberToIdentifer(module.usedExports.length) : \"__webpack_init__\";\n    let needExportsCopy = false;\n    const importedModules = new Map();\n    const initParams = [];\n    let index = 0;\n\n    for (const dep of module.dependencies) {\n      const depAsAny =\n      /** @type {any} */\n      dep;\n\n      if (dep.module) {\n        let importData = importedModules.get(dep.module);\n\n        if (importData === undefined) {\n          importedModules.set(dep.module, importData = {\n            importVar: `m${index}`,\n            index,\n            request: \"userRequest\" in depAsAny ? depAsAny.userRequest : undefined,\n            names: new Set(),\n            reexports: []\n          });\n          index++;\n        }\n\n        if (dep instanceof WebAssemblyImportDependency) {\n          importData.names.add(dep.name);\n\n          if (dep.description.type === \"GlobalType\") {\n            const exportName = dep.name;\n            const usedName = dep.module && dep.module.isUsed(exportName);\n\n            if (dep.module) {\n              if (usedName) {\n                initParams.push(runtimeTemplate.exportFromImport({\n                  module: dep.module,\n                  request: dep.request,\n                  importVar: importData.importVar,\n                  originModule: module,\n                  exportName: dep.name,\n                  asiSafe: true,\n                  isCall: false,\n                  callContext: null\n                }));\n              }\n            }\n          }\n        }\n\n        if (dep instanceof WebAssemblyExportImportedDependency) {\n          importData.names.add(dep.name);\n          const usedName = module.isUsed(dep.exportName);\n\n          if (usedName) {\n            const exportProp = `${module.exportsArgument}[${JSON.stringify(usedName)}]`;\n            const defineStatement = Template.asString([`${exportProp} = ${runtimeTemplate.exportFromImport({\n              module: dep.module,\n              request: dep.request,\n              importVar: importData.importVar,\n              originModule: module,\n              exportName: dep.name,\n              asiSafe: true,\n              isCall: false,\n              callContext: null\n            })};`, `if(WebAssembly.Global) ${exportProp} = ` + `new WebAssembly.Global({ value: ${JSON.stringify(dep.valueType)} }, ${exportProp});`]);\n            importData.reexports.push(defineStatement);\n            needExportsCopy = true;\n          }\n        }\n      }\n    }\n\n    const importsCode = Template.asString(Array.from(importedModules, _ref => {\n      let _ref2 = _slicedToArray(_ref, 2),\n          module = _ref2[0],\n          _ref2$ = _ref2[1],\n          importVar = _ref2$.importVar,\n          request = _ref2$.request,\n          reexports = _ref2$.reexports;\n\n      const importStatement = runtimeTemplate.importStatement({\n        module,\n        request,\n        importVar,\n        originModule: module\n      });\n      return importStatement + reexports.join(\"\\n\");\n    })); // create source\n\n    const source = new RawSource(['\"use strict\";', \"// Instantiate WebAssembly module\", \"var wasmExports = __webpack_require__.w[module.i];\", !Array.isArray(module.usedExports) ? `__webpack_require__.r(${module.exportsArgument});` : \"\", // this must be before import for circular dependencies\n    \"// export exports from WebAssembly module\", Array.isArray(module.usedExports) && !needExportsCopy ? `${module.moduleArgument}.exports = wasmExports;` : \"for(var name in wasmExports) \" + `if(name != ${JSON.stringify(initIdentifer)}) ` + `${module.exportsArgument}[name] = wasmExports[name];`, \"// exec imports from WebAssembly module (for esm order)\", importsCode, \"\", \"// exec wasm module\", `wasmExports[${JSON.stringify(initIdentifer)}](${initParams.join(\", \")})`].join(\"\\n\"));\n    return source;\n  }\n\n}\n\nmodule.exports = WebAssemblyJavascriptGenerator;","map":null,"metadata":{},"sourceType":"module"}