{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Sean Larkin @thelarkinn\n*/\n\"use strict\";\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\n\nfunction _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nconst EntrypointsOverSizeLimitWarning = require(\"./EntrypointsOverSizeLimitWarning\");\n\nconst AssetsOverSizeLimitWarning = require(\"./AssetsOverSizeLimitWarning\");\n\nconst NoAsyncChunksWarning = require(\"./NoAsyncChunksWarning\");\n/** @typedef {import(\"../Compiler\")} Compiler */\n\n/** @typedef {import(\"../Entrypoint\")} Entrypoint */\n\n\nmodule.exports = class SizeLimitsPlugin {\n  constructor(options) {\n    this.hints = options.hints;\n    this.maxAssetSize = options.maxAssetSize;\n    this.maxEntrypointSize = options.maxEntrypointSize;\n    this.assetFilter = options.assetFilter;\n  }\n  /**\n   * @param {Compiler} compiler webpack compiler\n   * @returns {void}\n   */\n\n\n  apply(compiler) {\n    const entrypointSizeLimit = this.maxEntrypointSize;\n    const assetSizeLimit = this.maxAssetSize;\n    const hints = this.hints;\n\n    const assetFilter = this.assetFilter || ((name, source, info) => !info.development);\n\n    compiler.hooks.afterEmit.tap(\"SizeLimitsPlugin\", compilation => {\n      const warnings = [];\n      /**\n       * @param {Entrypoint} entrypoint an entrypoint\n       * @returns {number} the size of the entrypoint\n       */\n\n      const getEntrypointSize = entrypoint => entrypoint.getFiles().reduce((currentSize, file) => {\n        const asset = compilation.getAsset(file);\n\n        if (asset && assetFilter(asset.name, asset.source, asset.info) && asset.source) {\n          return currentSize + (asset.info.size || asset.source.size());\n        }\n\n        return currentSize;\n      }, 0);\n\n      const assetsOverSizeLimit = [];\n\n      for (const _ref of compilation.getAssets()) {\n        const name = _ref.name;\n        const source = _ref.source;\n        const info = _ref.info;\n\n        if (!assetFilter(name, source, info) || !source) {\n          continue;\n        }\n\n        const size = info.size || source.size();\n\n        if (size > assetSizeLimit) {\n          assetsOverSizeLimit.push({\n            name,\n            size\n          });\n          /** @type {any} */\n\n          source.isOverSizeLimit = true;\n        }\n      }\n\n      const fileFilter = name => {\n        const asset = compilation.getAsset(name);\n        return asset && assetFilter(asset.name, asset.source, asset.info);\n      };\n\n      const entrypointsOverLimit = [];\n\n      for (const _ref2 of compilation.entrypoints) {\n        var _ref3 = _slicedToArray(_ref2, 2);\n\n        const name = _ref3[0];\n        const entry = _ref3[1];\n        const size = getEntrypointSize(entry);\n\n        if (size > entrypointSizeLimit) {\n          entrypointsOverLimit.push({\n            name: name,\n            size: size,\n            files: entry.getFiles().filter(fileFilter)\n          });\n          /** @type {any} */\n\n          entry.isOverSizeLimit = true;\n        }\n      }\n\n      if (hints) {\n        // 1. Individual Chunk: Size < 250kb\n        // 2. Collective Initial Chunks [entrypoint] (Each Set?): Size < 250kb\n        // 3. No Async Chunks\n        // if !1, then 2, if !2 return\n        if (assetsOverSizeLimit.length > 0) {\n          warnings.push(new AssetsOverSizeLimitWarning(assetsOverSizeLimit, assetSizeLimit));\n        }\n\n        if (entrypointsOverLimit.length > 0) {\n          warnings.push(new EntrypointsOverSizeLimitWarning(entrypointsOverLimit, entrypointSizeLimit));\n        }\n\n        if (warnings.length > 0) {\n          const hasAsyncChunks = compilation.chunks.filter(chunk => !chunk.canBeInitial()).length > 0;\n\n          if (!hasAsyncChunks) {\n            warnings.push(new NoAsyncChunksWarning());\n          }\n\n          if (hints === \"error\") {\n            compilation.errors.push(...warnings);\n          } else {\n            compilation.warnings.push(...warnings);\n          }\n        }\n      }\n    });\n  }\n\n};","map":null,"metadata":{},"sourceType":"module"}